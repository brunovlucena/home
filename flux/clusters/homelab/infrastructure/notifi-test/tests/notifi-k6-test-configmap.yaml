apiVersion: v1
kind: ConfigMap
metadata:
  name: notifi-k6-test
  namespace: notifi-test
  labels:
    app: notifi-k6-test
    component: testing
data:
  k6-tests.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Trend } from 'k6/metrics';

    // Custom metrics
    export const errorRate = new Rate('error_rate');
    export const responseTime = new Trend('response_time');

    // Test configuration
    export const options = {
      stages: [
        { duration: '30s', target: 10 }, // Ramp up
        { duration: '2m', target: 20 },  // Stay at 20 users
        { duration: '30s', target: 0 },  // Ramp down
      ],
      thresholds: {
        http_req_duration: ['p(95)<500'], // 95% of requests must complete below 500ms
        http_req_failed: ['rate<0.1'],   // Error rate must be below 10%
        error_rate: ['rate<0.1'],
      },
    };

    // Service configurations
    const services = {
      gateways: [
        { name: 'Management Gateway', url: 'http://mock-management-gateway:5000', health: 'http://mock-management-gateway:6000', metrics: 'http://mock-management-gateway:7000' },
        { name: 'Dataplane Gateway', url: 'http://mock-dataplane-gateway:80', health: 'http://mock-dataplane-gateway:6000', metrics: 'http://mock-dataplane-gateway:7000' },
      ],
      managers: [
        { name: 'User Manager', url: 'http://mock-user-manager:4000' },
        { name: 'Template Manager', url: 'http://mock-template-manager:4000' },
        { name: 'Tenant Manager', url: 'http://mock-tenant-manager:4000' },
        { name: 'Blockchain Manager', url: 'http://mock-blockchain-manager:4000' },
        { name: 'Chat Manager', url: 'http://mock-chat-manager:4000' },
        { name: 'Storage Manager', url: 'http://mock-storage-manager:4000' },
        { name: 'Fusion Manager', url: 'http://mock-fusion-manager:4000' },
        { name: 'Subscription Manager', url: 'http://mock-subscription-manager:4000' },
        { name: 'Points Manager', url: 'http://mock-points-manager:4000' },
        { name: 'Scheduler', url: 'http://mock-scheduler:4000' },
        { name: 'Rate Limit Broker', url: 'http://mock-rate-limit-broker:4000' },
      ],
      messengers: [
        { name: 'Mailer', url: 'http://mock-mailer:5000' },
        { name: 'SMS Messenger', url: 'http://mock-sms-messenger:5000' },
        { name: 'Telegram Messenger', url: 'http://mock-telegram-messenger:5000' },
        { name: 'FCM Messenger', url: 'http://mock-fcm-messenger:5000' },
        { name: 'Discord Messenger', url: 'http://mock-discord-messenger:5000' },
        { name: 'Slack Channel Messenger', url: 'http://mock-slack-channel-messenger:5000' },
        { name: 'Web Push Messenger', url: 'http://mock-web-push-messenger:5000' },
        { name: 'Web3 Messenger', url: 'http://mock-web3-messenger:5000' },
        { name: 'Webhook Sender', url: 'http://mock-webhook-sender:5000' },
      ],
      proxies: [
        { name: 'EVM Proxy', url: 'http://mock-evm-proxy:7000' },
        { name: 'Solana Proxy', url: 'http://mock-solana-proxy:7000' },
        { name: 'Aptos Proxy', url: 'http://mock-aptos-proxy:7000' },
        { name: 'SUI Proxy', url: 'http://mock-sui-proxy:7000' },
        { name: 'Cosmos Proxy', url: 'http://mock-cosmos-proxy:7000' },
        { name: 'BTC Proxy', url: 'http://mock-btc-proxy:7000' },
        { name: 'XMTP Proxy', url: 'http://mock-xmtp-proxy:5000' },
        { name: 'RPC Proxy', url: 'http://mock-rpc-proxy:80' },
        { name: 'Fetch Proxy', url: 'http://mock-fetch-proxy:4000' },
      ],
      databases: [
        { name: 'ClickHouse', url: 'http://mock-clickhouse:8123' },
        { name: 'ClickHouse Native', url: 'http://mock-clickhouse:9000' },
      ],
      monitoring: [
        { name: 'Monitor', url: 'http://mock-monitor:5000', health: 'http://mock-monitor:6000', metrics: 'http://mock-monitor:7000' },
      ],
      processors: [
        { name: 'Event Processor', url: 'http://mock-event-processor:5000', health: 'http://mock-event-processor:6000', metrics: 'http://mock-event-processor:7000' },
      ],
      handlers: [
        { name: 'Callback Handler', url: 'http://mock-callback-handler:5000', health: 'http://mock-callback-handler:6000', metrics: 'http://mock-callback-handler:7000' },
      ],
      services: [
        { name: 'Outpost Service', url: 'http://mock-outpost-service:5000', health: 'http://mock-outpost-service:6000', metrics: 'http://mock-outpost-service:7000' },
      ],
      grpcServers: [
        { name: 'gRPC Server', health: 'http://mock-grpc-server:6000', metrics: 'http://mock-grpc-server:7000' },
      ],
      websocketServers: [
        { name: 'WebSocket Server', health: 'http://mock-websocket-server:6000', metrics: 'http://mock-websocket-server:7000' },
      ],
    };

    // Helper function to test a service
    function testService(service, testName) {
      const startTime = Date.now();
      
      // Test main endpoint
      if (service.url) {
        const response = http.get(service.url);
        const success = check(response, {
          [`${testName} - ${service.name} HTTP`]: (r) => r.status === 200,
        });
        errorRate.add(!success);
      }
      
      // Test health endpoint
      if (service.health) {
        const healthResponse = http.get(service.health);
        const healthSuccess = check(healthResponse, {
          [`${testName} - ${service.name} Health`]: (r) => r.status === 200,
        });
        errorRate.add(!healthSuccess);
      }
      
      // Test metrics endpoint
      if (service.metrics) {
        const metricsResponse = http.get(service.metrics);
        const metricsSuccess = check(metricsResponse, {
          [`${testName} - ${service.name} Metrics`]: (r) => r.status === 200,
        });
        errorRate.add(!metricsSuccess);
      }
      
      const duration = Date.now() - startTime;
      responseTime.add(duration);
      
      sleep(0.1);
    }

    // Gateway Services Test
    export function testGateways() {
      console.log('Testing Gateway Services...');
      
      services.gateways.forEach(gateway => {
        testService(gateway, 'Gateway');
      });
    }

    // Manager Services Test
    export function testManagers() {
      console.log('Testing Manager Services...');
      
      services.managers.forEach(manager => {
        const managerWithHealth = Object.assign({}, manager, {
          health: `${manager.url}/health`,
          metrics: `${manager.url}/metrics`
        });
        testService(managerWithHealth, 'Manager');
      });
    }

    // Messenger Services Test
    export function testMessengers() {
      console.log('Testing Messenger Services...');
      
      services.messengers.forEach(messenger => {
        const messengerWithEndpoints = Object.assign({}, messenger, {
          health: `${messenger.url}/health`,
          metrics: `${messenger.url}/metrics`
        });
        testService(messengerWithEndpoints, 'Messenger');
      });
    }

    // Proxy Services Test
    export function testProxies() {
      console.log('Testing Proxy Services...');
      
      services.proxies.forEach(proxy => {
        const proxyWithEndpoints = Object.assign({}, proxy, {
          health: `${proxy.url}/health`,
          metrics: `${proxy.url}/metrics`
        });
        testService(proxyWithEndpoints, 'Proxy');
      });
    }

    // Database Services Test
    export function testDatabases() {
      console.log('Testing Database Services...');
      
      services.databases.forEach(database => {
        testService(database, 'Database');
      });
    }

    // Monitoring Services Test
    export function testMonitoring() {
      console.log('Testing Monitoring Services...');
      
      services.monitoring.forEach(monitor => {
        testService(monitor, 'Monitoring');
      });
    }

    // Processor Services Test
    export function testProcessors() {
      console.log('Testing Processor Services...');
      
      services.processors.forEach(processor => {
        testService(processor, 'Processor');
      });
    }

    // Handler Services Test
    export function testHandlers() {
      console.log('Testing Handler Services...');
      
      services.handlers.forEach(handler => {
        testService(handler, 'Handler');
      });
    }

    // Service Components Test
    export function testServiceComponents() {
      console.log('Testing Service Components...');
      
      services.services.forEach(service => {
        testService(service, 'Service');
      });
    }

    // gRPC Server Services Test
    export function testGrpcServers() {
      console.log('Testing gRPC Server Services...');
      
      services.grpcServers.forEach(grpcServer => {
        testService(grpcServer, 'gRPC Server');
      });
    }

    // WebSocket Server Services Test
    export function testWebSocketServers() {
      console.log('Testing WebSocket Server Services...');
      
      services.websocketServers.forEach(websocketServer => {
        testService(websocketServer, 'WebSocket Server');
      });
    }

    // Comprehensive Integration Test
    export function testIntegration() {
      console.log('Starting Comprehensive Integration Tests...');
      
      // Test all service types systematically
      console.log('=== GATEWAY SERVICES ===');
      testGateways();
      
      console.log('=== MANAGER SERVICES ===');
      testManagers();
      
      console.log('=== MESSENGER SERVICES ===');
      testMessengers();
      
      console.log('=== PROXY SERVICES ===');
      testProxies();
      
      console.log('=== DATABASE SERVICES ===');
      testDatabases();
      
      console.log('=== MONITORING SERVICES ===');
      testMonitoring();
      
      console.log('=== PROCESSOR SERVICES ===');
      testProcessors();
      
      console.log('=== HANDLER SERVICES ===');
      testHandlers();
      
      console.log('=== SERVICE COMPONENTS ===');
      testServiceComponents();
      
      console.log('=== gRPC SERVER SERVICES ===');
      testGrpcServers();
      
      console.log('=== WEBSOCKET SERVER SERVICES ===');
      testWebSocketServers();
      
      console.log('=== INTEGRATION TESTS COMPLETED ===');
    }

    // Load Testing Scenarios
    export function loadTestGateways() {
      console.log('Starting Gateway Load Tests...');
      
      for (let i = 0; i < 100; i++) {
        services.gateways.forEach(gateway => {
          if (gateway.url) {
            const response = http.get(gateway.url);
            check(response, {
              [`Load Test - ${gateway.name}`]: (r) => r.status === 200,
            });
          }
        });
        sleep(0.1);
      }
    }

    export function loadTestManagers() {
      console.log('Starting Manager Load Tests...');
      
      for (let i = 0; i < 50; i++) {
        services.managers.forEach(manager => {
          const healthUrl = `${manager.url}/health`;
          const metricsUrl = `${manager.url}/metrics`;
          
          const healthResponse = http.get(healthUrl);
          const metricsResponse = http.get(metricsUrl);
          
          check(healthResponse, {
            [`Load Test - ${manager.name} Health`]: (r) => r.status === 200,
          });
          check(metricsResponse, {
            [`Load Test - ${manager.name} Metrics`]: (r) => r.status === 200,
          });
        });
        sleep(0.1);
      }
    }

    export function loadTestMessengers() {
      console.log('Starting Messenger Load Tests...');
      
      for (let i = 0; i < 50; i++) {
        services.messengers.forEach(messenger => {
          const healthUrl = `${messenger.url}/health`;
          const metricsUrl = `${messenger.url}/metrics`;
          
          const mainResponse = http.get(messenger.url);
          const healthResponse = http.get(healthUrl);
          const metricsResponse = http.get(metricsUrl);
          
          check(mainResponse, {
            [`Load Test - ${messenger.name} HTTP`]: (r) => r.status === 200,
          });
          check(healthResponse, {
            [`Load Test - ${messenger.name} Health`]: (r) => r.status === 200,
          });
          check(metricsResponse, {
            [`Load Test - ${messenger.name} Metrics`]: (r) => r.status === 200,
          });
        });
        sleep(0.1);
      }
    }

    // Network Policy Test
    export function testNetworkPolicies() {
      console.log('Testing Network Policies and Security...');
      
      // Test gateway services
      services.gateways.forEach(gateway => {
        if (gateway.url) {
          const response = http.get(gateway.url);
          const success = check(response, {
            [`Network Policy - ${gateway.name} accessible`]: (r) => r.status === 200,
          });
          console.log(`${gateway.name}: ${success ? 'accessible' : 'not accessible'}`);
        }
      });
      
      // Test manager services
      services.managers.slice(0, 2).forEach(manager => {
        const healthUrl = `${manager.url}/health`;
        const response = http.get(healthUrl);
        const success = check(response, {
          [`Network Policy - ${manager.name} accessible`]: (r) => r.status === 200,
        });
        console.log(`${manager.name}: ${success ? 'accessible' : 'not accessible'}`);
      });
      
      // Test messenger services
      services.messengers.slice(0, 2).forEach(messenger => {
        const response = http.get(messenger.url);
        const success = check(response, {
          [`Network Policy - ${messenger.name} accessible`]: (r) => r.status === 200,
        });
        console.log(`${messenger.name}: ${success ? 'accessible' : 'not accessible'}`);
      });
      
      // Test proxy services
      services.proxies.slice(0, 2).forEach(proxy => {
        const response = http.get(proxy.url);
        const success = check(response, {
          [`Network Policy - ${proxy.name} accessible`]: (r) => r.status === 200,
        });
        console.log(`${proxy.name}: ${success ? 'accessible' : 'not accessible'}`);
      });
      
      // Test database services
      services.databases.forEach(database => {
        const response = http.get(database.url);
        const success = check(response, {
          [`Network Policy - ${database.name} accessible`]: (r) => r.status === 200,
        });
        console.log(`${database.name}: ${success ? 'accessible' : 'not accessible'}`);
      });
      
      // Test monitoring services
      services.monitoring.forEach(monitor => {
        if (monitor.url) {
          const response = http.get(monitor.url);
          const success = check(response, {
            [`Network Policy - ${monitor.name} accessible`]: (r) => r.status === 200,
          });
          console.log(`${monitor.name}: ${success ? 'accessible' : 'not accessible'}`);
        }
      });
    }

    // Metrics Collection Test
    export function collectMetrics() {
      console.log('Collecting Metrics from All Services...');
      
      const allServices = services.gateways
        .concat(services.managers.map(m => Object.assign({}, m, { metrics: `${m.url}/metrics` })))
        .concat(services.messengers.map(m => Object.assign({}, m, { metrics: `${m.url}/metrics` })))
        .concat(services.proxies.map(p => Object.assign({}, p, { metrics: `${p.url}/metrics` })))
        .concat(services.monitoring)
        .concat(services.processors)
        .concat(services.handlers)
        .concat(services.services)
        .concat(services.grpcServers)
        .concat(services.websocketServers);
      
      allServices.forEach(service => {
        if (service.metrics) {
          console.log(`Collecting metrics from ${service.name}`);
          const response = http.get(service.metrics);
          if (response.status === 200) {
            console.log(`✓ ${service.name} metrics collected`);
          } else {
            console.log(`✗ ${service.name} metrics collection failed`);
          }
        }
      });
    }

    // Health Check Test
    export function healthCheck() {
      console.log('Running Health Checks...');
      
      const allServices = services.gateways
        .map(g => Object.assign({}, g, { health: g.health || `${g.url}/health` }))
        .concat(services.managers.map(m => Object.assign({}, m, { health: `${m.url}/health` })))
        .concat(services.messengers.map(m => Object.assign({}, m, { health: `${m.url}/health` })))
        .concat(services.proxies.map(p => Object.assign({}, p, { health: `${p.url}/health` })))
        .concat(services.monitoring)
        .concat(services.processors)
        .concat(services.handlers)
        .concat(services.services)
        .concat(services.grpcServers)
        .concat(services.websocketServers);
      
      let healthyCount = 0;
      const totalCount = allServices.length;
      
      allServices.forEach(service => {
        if (service.health) {
          const response = http.get(service.health);
          const isHealthy = response.status === 200;
          if (isHealthy) {
            console.log(`✓ ${service.name} is healthy`);
            healthyCount++;
          } else {
            console.log(`✗ ${service.name} is unhealthy`);
          }
        }
      });
      
      console.log(`Health check summary: ${healthyCount}/${totalCount} services healthy`);
      
      if (healthyCount === totalCount) {
        console.log('All services are healthy!');
      } else {
        console.log('Some services are unhealthy!');
      }
    }

    // Main test function - runs all tests
    export default function() {
      console.log('Starting Notifi Mock Infrastructure Tests...');
      
      // Run comprehensive integration test
      testIntegration();
      
      // Run load tests
      loadTestGateways();
      loadTestManagers();
      loadTestMessengers();
      
      // Run network policy tests
      testNetworkPolicies();
      
      // Collect metrics
      collectMetrics();
      
      // Run health checks
      healthCheck();
      
      console.log('All tests completed!');
    }
