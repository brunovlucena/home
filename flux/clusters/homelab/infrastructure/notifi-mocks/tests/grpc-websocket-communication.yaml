---
# Mock gRPC Server Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mock-grpc-server
  namespace: mocks
  labels:
    app.kubernetes.io/name: grpc-server-test
    app.kubernetes.io/component: grpc-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: grpc-server-test
  template:
    metadata:
      labels:
        app.kubernetes.io/name: grpc-server-test
        app.kubernetes.io/component: grpc-server
    spec:
      containers:
      - name: grpc-server
        image: python:3.11-alpine
        ports:
        - containerPort: 50051
        - containerPort: 50052
        - containerPort: 50053
        - containerPort: 6000
        - containerPort: 7000
        command: ["/bin/sh"]
        args:
        - -c
        - |
          # Install Python and gRPC tools
          apk add --no-cache python3 py3-pip curl gcc musl-dev
          pip3 install grpcio grpcio-tools
          
          # Create a simple gRPC server
          cat > /tmp/grpc_server.py << 'EOF'
          import grpc
          from concurrent import futures
          import time
          import threading
          from grpc_reflection.v1alpha import reflection
          
          class TestServiceServicer:
              def __init__(self):
                  self.request_count = 0
              
              def UnaryCall(self, request, context):
                  self.request_count += 1
                  return type('Response', (), {
                      'message': f'Hello from gRPC server! Request #{self.request_count}',
                      'timestamp': int(time.time()),
                      'request_id': request.id if hasattr(request, 'id') else 'unknown'
                  })()
              
              def StreamingCall(self, request, context):
                  for i in range(5):
                      yield type('Response', (), {
                          'message': f'Streaming response #{i+1}',
                          'timestamp': int(time.time())
                      })()
                      time.sleep(0.1)
              
              def BidirectionalStreamingCall(self, request_iterator, context):
                  for request in request_iterator:
                      yield type('Response', (), {
                          'message': f'Bidirectional response for: {request.message if hasattr(request, "message") else "unknown"}',
                          'timestamp': int(time.time())
                      })()
          
          def serve():
              server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
              
              # Add reflection service
              reflection.enable_server_reflection([], server)
              
              # Start server
              server.add_insecure_port('[::]:50051')
              server.start()
              print("gRPC server started on port 50051")
              
              try:
                  while True:
                      time.sleep(86400)
              except KeyboardInterrupt:
                  server.stop(0)
          
          if __name__ == '__main__':
              serve()
          EOF
          
          # Start gRPC server
          python3 /tmp/grpc_server.py &
          
          # Health check endpoint
          python3 -m http.server 6000 &
          
          # Metrics endpoint
          python3 -c "
          from http.server import HTTPServer, BaseHTTPRequestHandler
          import json
          
          class MetricsHandler(BaseHTTPRequestHandler):
              def do_GET(self):
                  if self.path == '/metrics':
                      self.send_response(200)
                      self.send_header('Content-type', 'text/plain')
                      self.end_headers()
                      self.wfile.write(b'# HELP grpc_requests_total Total gRPC requests\n')
                      self.wfile.write(b'# TYPE grpc_requests_total counter\n')
                      self.wfile.write(b'grpc_requests_total{method=\"UnaryCall\"} 0\n')
                      self.wfile.write(b'grpc_requests_total{method=\"StreamingCall\"} 0\n')
                      self.wfile.write(b'grpc_requests_total{method=\"BidirectionalStreamingCall\"} 0\n')
                  else:
                      self.send_response(404)
                      self.end_headers()
          
          HTTPServer(('0.0.0.0', 7000), MetricsHandler).serve_forever()
          " &

---
apiVersion: v1
kind: Service
metadata:
  name: mock-grpc-server
  namespace: mocks
  labels:
    app.kubernetes.io/name: grpc-server-test
    app.kubernetes.io/component: grpc-server
spec:
  selector:
    app.kubernetes.io/name: grpc-server-test
  ports:
  - name: grpc
    port: 50051
    targetPort: 50051
  - name: grpc-alt1
    port: 50052
    targetPort: 50052
  - name: grpc-alt2
    port: 50053
    targetPort: 50053
  - name: health
    port: 6000
    targetPort: 6000
  - name: metrics
    port: 7000
    targetPort: 7000
  type: ClusterIP

---
# Mock WebSocket Server Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mock-websocket-server
  namespace: mocks
  labels:
    app.kubernetes.io/name: websocket-server-test
    app.kubernetes.io/component: websocket-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: websocket-server-test
  template:
    metadata:
      labels:
        app.kubernetes.io/name: websocket-server-test
        app.kubernetes.io/component: websocket-server
    spec:
      containers:
      - name: websocket-server
        image: python:3.11-alpine
        ports:
        - containerPort: 8080
        - containerPort: 8081
        - containerPort: 8082
        - containerPort: 6000
        - containerPort: 7000
        command: ["/bin/sh"]
        args:
        - -c
        - |
          # Install dependencies
          apk add --no-cache python3 py3-pip gcc musl-dev
          pip install websockets flask
          
          # Create WebSocket server
          cat > /tmp/websocket_server.py << 'EOF'
          import asyncio
          import websockets
          import json
          import time
          from flask import Flask, jsonify
          import threading
          
          app = Flask(__name__)
          connection_count = 0
          message_count = 0
          clients = set()
          
          async def handle_client(websocket, path):
              global connection_count, message_count
              connection_count += 1
              client_id = f"client-{connection_count}"
              clients.add(websocket)
              
              print(f"New WebSocket connection: {client_id}")
              
              # Send welcome message
              welcome_msg = {
                  'type': 'welcome',
                  'message': f'Welcome {client_id}!',
                  'timestamp': int(time.time() * 1000),
                  'clientId': client_id
              }
              await websocket.send(json.dumps(welcome_msg))
              
              try:
                  async for message in websocket:
                      message_count += 1
                      try:
                          data = json.loads(message)
                          print(f"Received from {client_id}: {data}")
                          
                          # Echo back the message
                          echo_msg = {
                              "type": "echo",
                              "originalMessage": data,
                              "timestamp": int(time.time() * 1000),
                              "messageId": message_count
                          }
                          await websocket.send(json.dumps(echo_msg))
                          
                          # Send periodic updates for subscribe messages
                          if data.get("type") == "subscribe":
                              asyncio.create_task(send_periodic_updates(websocket, client_id))
                              
                      except json.JSONDecodeError:
                          error_msg = {
                              "type": "error",
                              "message": "Invalid JSON message",
                              "timestamp": int(time.time() * 1000)
                          }
                          await websocket.send(json.dumps(error_msg))
              except websockets.exceptions.ConnectionClosed:
                  print(f"WebSocket connection closed: {client_id}")
              finally:
                  clients.discard(websocket)
          
          async def send_periodic_updates(websocket, client_id):
              global message_count
              while websocket in clients:
                  try:
                      update_msg = {
                          "type": "update",
                          "message": f"Periodic update #{message_count}",
                          "timestamp": int(time.time() * 1000),
                          "clientId": client_id
                      }
                      await websocket.send(json.dumps(update_msg))
                      await asyncio.sleep(1)
                  except websockets.exceptions.ConnectionClosed:
                      break
          
          # Flask health check endpoint
          @app.route("/health")
          def health():
              return jsonify({
                  "status": "healthy",
                  "connections": connection_count,
                  "messages": message_count,
                  "timestamp": int(time.time() * 1000)
              })
          
          # Flask metrics endpoint
          @app.route("/metrics")
          def metrics():
              return f"""# HELP websocket_connections_total Total WebSocket connections
          # TYPE websocket_connections_total counter
          websocket_connections_total {connection_count}
          
          # HELP websocket_messages_total Total WebSocket messages
          # TYPE websocket_messages_total counter
          websocket_messages_total {message_count}
          """, 200, {"Content-Type": "text/plain"}
          
          def run_flask():
              app.run(host="0.0.0.0", port=6000, debug=False)
          
          async def main():
              # Start Flask in a separate thread
              flask_thread = threading.Thread(target=run_flask)
              flask_thread.daemon = True
              flask_thread.start()
              
              # Start WebSocket server
              async with websockets.serve(handle_client, "0.0.0.0", 8080):
                  print("WebSocket server started on port 8080")
                  await asyncio.Future()  # run forever
          
          if __name__ == '__main__':
              asyncio.run(main())
          EOF
          
          # Start WebSocket server
          python3 /tmp/websocket_server.py

---
apiVersion: v1
kind: Service
metadata:
  name: mock-websocket-server
  namespace: mocks
  labels:
    app.kubernetes.io/name: websocket-server-test
    app.kubernetes.io/component: websocket-server
spec:
  selector:
    app.kubernetes.io/name: websocket-server-test
  ports:
  - name: websocket
    port: 8080
    targetPort: 8080
  - name: websocket-alt1
    port: 8081
    targetPort: 8081
  - name: websocket-alt2
    port: 8082
    targetPort: 8082
  - name: health
    port: 6000
    targetPort: 6000
  - name: metrics
    port: 7000
    targetPort: 7000
  type: ClusterIP

---
# gRPC Communication Test Pod
apiVersion: v1
kind: Pod
metadata:
  name: test-grpc-communication
  namespace: mocks
  labels:
    app.kubernetes.io/name: grpc-communication-test
    app.kubernetes.io/component: test
spec:
  containers:
  - name: grpc-client
    image: python:3.11-alpine
    command: ["/bin/sh"]
    args:
    - -c
    - |
      echo "Starting gRPC communication tests..."
      
      # Install Python and gRPC tools
      apk add --no-cache python3 py3-pip curl gcc musl-dev
      pip3 install grpcio grpcio-tools
      
      # Wait for gRPC server to be ready
      echo "Waiting for gRPC server to be ready..."
      for i in {1..30}; do
        if curl -f http://mock-grpc-server:6000/ >/dev/null 2>&1; then
          echo "gRPC server is ready!"
          break
        fi
        echo "Waiting for gRPC server... ($i/30)"
        sleep 2
      done
      
      # Create gRPC client test
      cat > /tmp/grpc_client_test.py << 'EOF'
      import grpc
      import time
      import threading
      from concurrent import futures
      
      def test_grpc_connection():
          try:
              # Test basic connection
              channel = grpc.insecure_channel('mock-grpc-server:50051')
              
              # Test connection with timeout
              try:
                  grpc.channel_ready_future(channel).result(timeout=10)
                  print("âœ… gRPC connection established successfully")
                  return True
              except grpc.RpcError as e:
                  print(f"âŒ gRPC connection failed: {e}")
                  return False
              
          except Exception as e:
              print(f"âŒ gRPC connection test failed: {e}")
              return False
          finally:
              if 'channel' in locals():
                  channel.close()
      
      def test_grpc_reflection():
          try:
              from grpc_reflection.v1alpha import reflection
              
              channel = grpc.insecure_channel('mock-grpc-server:50051')
              
              # Test reflection
              try:
                  stub = reflection.ServerReflectionStub(channel)
                  request = reflection.ServerReflectionRequest()
                  request.list_services = ""
                  
                  response = stub.ServerReflectionInfo(iter([request]))
                  print("âœ… gRPC reflection test successful")
                  return True
              except Exception as e:
                  print(f"âŒ gRPC reflection test failed: {e}")
                  return False
              finally:
                  channel.close()
                  
          except Exception as e:
              print(f"âŒ gRPC reflection test failed: {e}")
              return False
      
      def test_grpc_ports():
          ports = [50051, 50052, 50053]
          results = []
          
          for port in ports:
              try:
                  channel = grpc.insecure_channel(f'mock-grpc-server:{port}')
                  grpc.channel_ready_future(channel).result(timeout=5)
                  print(f"âœ… gRPC port {port} is accessible")
                  results.append(True)
                  channel.close()
              except Exception as e:
                  print(f"âŒ gRPC port {port} failed: {e}")
                  results.append(False)
          
          return all(results)
      
      def test_grpc_through_linkerd():
          try:
              # Test gRPC communication through Linkerd
              channel = grpc.insecure_channel('mock-grpc-server:50051')
              
              # Test with Linkerd headers
              metadata = [
                  ('l5d-dst-override', 'mock-grpc-server:50051'),
                  ('l5d-require-id', 'mock-grpc-server.notifi-test.serviceaccount.identity.linkerd.cluster.local')
              ]
              
              try:
                  grpc.channel_ready_future(channel).result(timeout=10)
                  print("âœ… gRPC communication through Linkerd successful")
                  return True
              except Exception as e:
                  print(f"âŒ gRPC communication through Linkerd failed: {e}")
                  return False
              finally:
                  channel.close()
                  
          except Exception as e:
              print(f"âŒ gRPC Linkerd test failed: {e}")
              return False
      
      if __name__ == '__main__':
          print("=== gRPC Communication Tests ===")
          
          tests = [
              ("Basic Connection", test_grpc_connection),
              ("Reflection", test_grpc_reflection),
              ("Multiple Ports", test_grpc_ports),
              ("Linkerd Integration", test_grpc_through_linkerd)
          ]
          
          results = []
          for test_name, test_func in tests:
              print(f"\n--- {test_name} Test ---")
              result = test_func()
              results.append((test_name, result))
          
          print("\n=== Test Results ===")
          passed = 0
          for test_name, result in results:
              status = "âœ… PASSED" if result else "âŒ FAILED"
              print(f"{test_name}: {status}")
              if result:
                  passed += 1
          
          print(f"\nTotal: {passed}/{len(results)} tests passed")
          exit(0 if passed == len(results) else 1)
      EOF
      
      # Run gRPC tests
      python3 /tmp/grpc_client_test.py
      
      echo "gRPC communication tests completed!"
  restartPolicy: Never

---
# WebSocket Communication Test Pod
apiVersion: v1
kind: Pod
metadata:
  name: test-websocket-communication
  namespace: mocks
  labels:
    app.kubernetes.io/name: websocket-communication-test
    app.kubernetes.io/component: test
spec:
  containers:
  - name: websocket-client
    image: node:alpine
    command: ["/bin/sh"]
    args:
    - -c
    - |
      echo "Starting WebSocket communication tests..."
      
      # Install dependencies
      npm install -g ws
      
      # Wait for WebSocket server to be ready
      echo "Waiting for WebSocket server to be ready..."
      for i in {1..30}; do
        if curl -f http://mock-websocket-server:6000/ >/dev/null 2>&1; then
          echo "WebSocket server is ready!"
          break
        fi
        echo "Waiting for WebSocket server... ($i/30)"
        sleep 2
      done
      
      # Create WebSocket client test
      cat > /tmp/websocket_client_test.js << 'EOF'
      const WebSocket = require('ws');
      const http = require('http');
      
      function testWebSocketConnection() {
          return new Promise((resolve) => {
              try {
                  const ws = new WebSocket('ws://mock-websocket-server:8080/ws');
                  
                  ws.on('open', () => {
                      console.log('âœ… WebSocket connection established');
                      ws.close();
                      resolve(true);
                  });
                  
                  ws.on('error', (error) => {
                      console.log(`âŒ WebSocket connection failed: ${error.message}`);
                      resolve(false);
                  });
                  
                  ws.on('close', () => {
                      console.log('WebSocket connection closed');
                  });
                  
              } catch (error) {
                  console.log(`âŒ WebSocket connection test failed: ${error.message}`);
                  resolve(false);
              }
          });
      }
      
      function testWebSocketMessageExchange() {
          return new Promise((resolve) => {
              try {
                  const ws = new WebSocket('ws://mock-websocket-server:8080/ws');
                  let messageReceived = false;
                  
                  ws.on('open', () => {
                      console.log('âœ… WebSocket connection for message test established');
                      
                      // Send test message
                      ws.send(JSON.stringify({
                          type: 'test',
                          message: 'Hello WebSocket server!',
                          timestamp: Date.now()
                      }));
                  });
                  
                  ws.on('message', (data) => {
                      try {
                          const message = JSON.parse(data);
                          console.log('âœ… WebSocket message received:', message.type);
                          messageReceived = true;
                          ws.close();
                      } catch (error) {
                          console.log(`âŒ Invalid WebSocket message: ${error.message}`);
                          ws.close();
                      }
                  });
                  
                  ws.on('error', (error) => {
                      console.log(`âŒ WebSocket message test failed: ${error.message}`);
                      resolve(false);
                  });
                  
                  ws.on('close', () => {
                      resolve(messageReceived);
                  });
                  
              } catch (error) {
                  console.log(`âŒ WebSocket message test failed: ${error.message}`);
                  resolve(false);
              }
          });
      }
      
      function testWebSocketStreaming() {
          return new Promise((resolve) => {
              try {
                  const ws = new WebSocket('ws://mock-websocket-server:8080/ws');
                  let messageCount = 0;
                  
                  ws.on('open', () => {
                      console.log('âœ… WebSocket connection for streaming test established');
                      
                      // Send subscribe message to trigger streaming
                      ws.send(JSON.stringify({
                          type: 'subscribe',
                          message: 'Start streaming updates',
                          timestamp: Date.now()
                      }));
                  });
                  
                  ws.on('message', (data) => {
                      try {
                          const message = JSON.parse(data);
                          messageCount++;
                          console.log(`âœ… WebSocket streaming message ${messageCount}:`, message.type);
                          
                          // Close after receiving 3 messages
                          if (messageCount >= 3) {
                              ws.close();
                          }
                      } catch (error) {
                          console.log(`âŒ Invalid WebSocket streaming message: ${error.message}`);
                          ws.close();
                      }
                  });
                  
                  ws.on('error', (error) => {
                      console.log(`âŒ WebSocket streaming test failed: ${error.message}`);
                      resolve(false);
                  });
                  
                  ws.on('close', () => {
                      const success = messageCount >= 2;
                      console.log(`âœ… WebSocket streaming test completed: ${messageCount} messages received`);
                      resolve(success);
                  });
                  
              } catch (error) {
                  console.log(`âŒ WebSocket streaming test failed: ${error.message}`);
                  resolve(false);
              }
          });
      }
      
      function testWebSocketPorts() {
          const ports = [8080, 8081, 8082];
          const promises = ports.map(port => {
              return new Promise((resolve) => {
                  try {
                      const ws = new WebSocket(`ws://mock-websocket-server:${port}/ws`);
                      
                      ws.on('open', () => {
                          console.log(`âœ… WebSocket port ${port} is accessible`);
                          ws.close();
                          resolve(true);
                      });
                      
                      ws.on('error', (error) => {
                          console.log(`âŒ WebSocket port ${port} failed: ${error.message}`);
                          resolve(false);
                      });
                      
                  } catch (error) {
                      console.log(`âŒ WebSocket port ${port} test failed: ${error.message}`);
                      resolve(false);
                  }
              });
          });
          
          return Promise.all(promises).then(results => results.every(r => r));
      }
      
      function testWebSocketThroughLinkerd() {
          return new Promise((resolve) => {
              try {
                  // Test WebSocket communication through Linkerd
                  const ws = new WebSocket('ws://mock-websocket-server:8080/ws', {
                      headers: {
                          'l5d-dst-override': 'mock-websocket-server:8080',
                          'l5d-require-id': 'mock-websocket-server.notifi-test.serviceaccount.identity.linkerd.cluster.local'
                      }
                  });
                  
                  ws.on('open', () => {
                      console.log('âœ… WebSocket communication through Linkerd successful');
                      ws.close();
                      resolve(true);
                  });
                  
                  ws.on('error', (error) => {
                      console.log(`âŒ WebSocket communication through Linkerd failed: ${error.message}`);
                      resolve(false);
                  });
                  
              } catch (error) {
                  console.log(`âŒ WebSocket Linkerd test failed: ${error.message}`);
                  resolve(false);
              }
          });
      }
      
      async function runTests() {
          console.log('=== WebSocket Communication Tests ===');
          
          const tests = [
              ['Basic Connection', testWebSocketConnection],
              ['Message Exchange', testWebSocketMessageExchange],
              ['Streaming', testWebSocketStreaming],
              ['Multiple Ports', testWebSocketPorts],
              ['Linkerd Integration', testWebSocketThroughLinkerd]
          ];
          
          const results = [];
          for (const [testName, testFunc] of tests) {
              console.log(`\n--- ${testName} Test ---`);
              const result = await testFunc();
              results.push([testName, result]);
          }
          
          console.log('\n=== Test Results ===');
          let passed = 0;
          for (const [testName, result] of results) {
              const status = result ? 'âœ… PASSED' : 'âŒ FAILED';
              console.log(`${testName}: ${status}`);
              if (result) passed++;
          }
          
          console.log(`\nTotal: ${passed}/${results.length} tests passed`);
          process.exit(passed === results.length ? 0 : 1);
      }
      
      runTests().catch(error => {
          console.error('Test execution failed:', error);
          process.exit(1);
      });
      EOF
      
      # Run WebSocket tests
      node /tmp/websocket_client_test.js
      
      echo "WebSocket communication tests completed!"
  restartPolicy: Never

---
# Comprehensive gRPC and WebSocket Integration Test Job
apiVersion: batch/v1
kind: Job
metadata:
  name: test-grpc-websocket-integration
  namespace: mocks
  labels:
    app.kubernetes.io/name: grpc-websocket-integration-test
    app.kubernetes.io/component: test
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/name: grpc-websocket-integration-test
        app.kubernetes.io/component: test
    spec:
      containers:
      - name: integration-test
        image: python:3.11-alpine
        command: ["/bin/sh"]
        args:
        - -c
        - |
          echo "Starting comprehensive gRPC and WebSocket integration tests..."
          
          # Install dependencies
          apk add --no-cache python3 py3-pip curl nodejs npm gcc musl-dev
          pip3 install grpcio grpcio-tools
          npm install -g ws
          
          # Wait for both servers to be ready
          echo "Waiting for servers to be ready..."
          for i in {1..60}; do
            grpc_ready=$(curl -f http://mock-grpc-server:6000/ >/dev/null 2>&1 && echo "true" || echo "false")
            ws_ready=$(curl -f http://mock-websocket-server:6000/ >/dev/null 2>&1 && echo "true" || echo "false")
            
            if [ "$grpc_ready" = "true" ] && [ "$ws_ready" = "true" ]; then
              echo "Both servers are ready!"
              break
            fi
            echo "Waiting for servers... ($i/60) - gRPC: $grpc_ready, WebSocket: $ws_ready"
            sleep 2
          done
          
          # Test 1: Basic connectivity
          echo "=== Test 1: Basic Connectivity ==="
          
          # Test gRPC server health
          curl -f http://mock-grpc-server:6000/ && echo "âœ… gRPC server health check passed" || echo "âŒ gRPC server health check failed"
          curl -f http://mock-grpc-server:7000/metrics && echo "âœ… gRPC server metrics accessible" || echo "âŒ gRPC server metrics failed"
          
          # Test WebSocket server health
          curl -f http://mock-websocket-server:6000/ && echo "âœ… WebSocket server health check passed" || echo "âŒ WebSocket server health check failed"
          curl -f http://mock-websocket-server:7000/metrics && echo "âœ… WebSocket server metrics accessible" || echo "âŒ WebSocket server metrics failed"
          
          # Test 2: gRPC communication
          echo "=== Test 2: gRPC Communication ==="
          
          cat > /tmp/grpc_integration_test.py << 'EOF'
          import grpc
          import time
          import json
          
          def test_grpc_integration():
              try:
                  # Test gRPC connection
                  channel = grpc.insecure_channel('mock-grpc-server:50051')
                  grpc.channel_ready_future(channel).result(timeout=10)
                  print("âœ… gRPC integration connection successful")
                  
                  # Test multiple ports
                  for port in [50051, 50052, 50053]:
                      try:
                          test_channel = grpc.insecure_channel(f'mock-grpc-server:{port}')
                          grpc.channel_ready_future(test_channel).result(timeout=5)
                          print(f"âœ… gRPC port {port} integration test passed")
                          test_channel.close()
                      except Exception as e:
                          print(f"âŒ gRPC port {port} integration test failed: {e}")
                  
                  channel.close()
                  return True
              except Exception as e:
                  print(f"âŒ gRPC integration test failed: {e}")
                  return False
          
          if __name__ == '__main__':
              result = test_grpc_integration()
              exit(0 if result else 1)
          EOF
          
          python3 /tmp/grpc_integration_test.py
          
          # Test 3: WebSocket communication
          echo "=== Test 3: WebSocket Communication ==="
          
          cat > /tmp/websocket_integration_test.js << 'EOF'
          const WebSocket = require('ws');
          
          function testWebSocketIntegration() {
              return new Promise((resolve) => {
                  try {
                      const ws = new WebSocket('ws://mock-websocket-server:8080/ws');
                      
                      ws.on('open', () => {
                          console.log('âœ… WebSocket integration connection successful');
                          
                          // Test message exchange
                          ws.send(JSON.stringify({
                              type: 'integration_test',
                              message: 'Integration test message',
                              timestamp: Date.now()
                          }));
                      });
                      
                      ws.on('message', (data) => {
                          try {
                              const message = JSON.parse(data);
                              console.log('âœ… WebSocket integration message received:', message.type);
                              ws.close();
                              resolve(true);
                          } catch (error) {
                              console.log('âŒ WebSocket integration message parsing failed:', error.message);
                              ws.close();
                              resolve(false);
                          }
                      });
                      
                      ws.on('error', (error) => {
                          console.log('âŒ WebSocket integration test failed:', error.message);
                          resolve(false);
                      });
                      
                  } catch (error) {
                      console.log('âŒ WebSocket integration test failed:', error.message);
                      resolve(false);
                  }
              });
          }
          
          testWebSocketIntegration().then(result => {
              process.exit(result ? 0 : 1);
          }).catch(error => {
              console.error('WebSocket integration test error:', error);
              process.exit(1);
          });
          EOF
          
          node /tmp/websocket_integration_test.js
          
          # Test 4: Concurrent communication
          echo "=== Test 4: Concurrent Communication ==="
          
          # Test concurrent gRPC and WebSocket connections
          cat > /tmp/concurrent_test.py << 'EOF'
          import grpc
          import threading
          import time
          import subprocess
          import sys
          
          def test_concurrent_grpc():
              try:
                  channel = grpc.insecure_channel('mock-grpc-server:50051')
                  grpc.channel_ready_future(channel).result(timeout=10)
                  print("âœ… Concurrent gRPC connection successful")
                  channel.close()
                  return True
              except Exception as e:
                  print(f"âŒ Concurrent gRPC test failed: {e}")
                  return False
          
          def test_concurrent_websocket():
              try:
                  result = subprocess.run([
                      'node', '-e', '''
                      const WebSocket = require('ws');
                      const ws = new WebSocket('ws://mock-websocket-server:8080/ws');
                      ws.on('open', () => {
                          console.log('âœ… Concurrent WebSocket connection successful');
                          ws.close();
                          process.exit(0);
                      });
                      ws.on('error', (error) => {
                          console.log('âŒ Concurrent WebSocket test failed:', error.message);
                          process.exit(1);
                      });
                      '''
                  ], capture_output=True, text=True, timeout=10)
                  
                  if result.returncode == 0:
                      print("âœ… Concurrent WebSocket test successful")
                      return True
                  else:
                      print("âŒ Concurrent WebSocket test failed")
                      return False
              except Exception as e:
                  print(f"âŒ Concurrent WebSocket test failed: {e}")
                  return False
          
          def run_concurrent_tests():
              grpc_thread = threading.Thread(target=test_concurrent_grpc)
              ws_thread = threading.Thread(target=test_concurrent_websocket)
              
              grpc_thread.start()
              ws_thread.start()
              
              grpc_thread.join()
              ws_thread.join()
              
              return True
          
          if __name__ == '__main__':
              result = run_concurrent_tests()
              exit(0 if result else 1)
          EOF
          
          python3 /tmp/concurrent_test.py
          
          # Test 5: Performance and load testing
          echo "=== Test 5: Performance and Load Testing ==="
          
          # Test multiple concurrent connections
          for i in {1..5}; do
            echo "Testing concurrent connection $i..."
            
  # Start gRPC test in background
  python3 -c '
  import grpc
  try:
      channel = grpc.insecure_channel("mock-grpc-server:50051")
      grpc.channel_ready_future(channel).result(timeout=5)
      print("âœ… Load test gRPC connection '$i' successful")
      channel.close()
  except Exception as e:
      print(f"âŒ Load test gRPC connection '$i' failed: {e}")
  ' &
            
  # Start WebSocket test in background
  node -e '
  const WebSocket = require("ws");
  const ws = new WebSocket("ws://mock-websocket-server:8080/ws");
  ws.on("open", () => {
      console.log("âœ… Load test WebSocket connection '$i' successful");
      ws.close();
  });
  ws.on("error", (error) => {
      console.log("âŒ Load test WebSocket connection '$i' failed:", error.message);
  });
  ' &
          done
          
          # Wait for all background processes
          wait
          
          # Test 6: Linkerd integration
          echo "=== Test 6: Linkerd Integration ==="
          
          # Test gRPC through Linkerd
          python3 -c '
          import grpc
          try:
              channel = grpc.insecure_channel("mock-grpc-server:50051")
              grpc.channel_ready_future(channel).result(timeout=10)
              print("âœ… gRPC Linkerd integration successful")
              channel.close()
          except Exception as e:
              print(f"âŒ gRPC Linkerd integration failed: {e}")
          '
          
          # Test WebSocket through Linkerd
          node -e '
          const WebSocket = require("ws");
          const ws = new WebSocket("ws://mock-websocket-server:8080/ws");
          ws.on("open", () => {
              console.log("âœ… WebSocket Linkerd integration successful");
              ws.close();
          });
          ws.on("error", (error) => {
              console.log("âŒ WebSocket Linkerd integration failed:", error.message);
          });
          '
          
          # Test 7: Error handling and resilience
          echo "=== Test 7: Error Handling and Resilience ==="
          
          # Test connection to non-existent service
          python3 -c '
          import grpc
          try:
              channel = grpc.insecure_channel("non-existent-service:50051")
              grpc.channel_ready_future(channel).result(timeout=5)
              print("âŒ gRPC error handling test failed - should have failed")
          except Exception as e:
              print("âœ… gRPC error handling test passed - correctly failed")
          '
          
          # Test WebSocket connection to non-existent service
          node -e '
          const WebSocket = require("ws");
          const ws = new WebSocket("ws://non-existent-service:8080/ws");
          ws.on("error", (error) => {
              console.log("âœ… WebSocket error handling test passed - correctly failed");
          });
          setTimeout(() => {
              console.log("âŒ WebSocket error handling test failed - should have failed");
          }, 5000);
          '
          
          # Test 8: Final validation
          echo "=== Test 8: Final Validation ==="
          
          # Check server health one more time
          curl -f http://mock-grpc-server:6000/ && echo "âœ… Final gRPC server health check passed" || echo "âŒ Final gRPC server health check failed"
          curl -f http://mock-websocket-server:6000/ && echo "âœ… Final WebSocket server health check passed" || echo "âŒ Final WebSocket server health check failed"
          
          # Check metrics
          curl -f http://mock-grpc-server:7000/metrics && echo "âœ… Final gRPC metrics check passed" || echo "âŒ Final gRPC metrics check failed"
          curl -f http://mock-websocket-server:7000/metrics && echo "âœ… Final WebSocket metrics check passed" || echo "âŒ Final WebSocket metrics check failed"
          
          echo ""
          echo "ğŸ‰ Comprehensive gRPC and WebSocket integration tests completed!"
          echo "âœ… gRPC Communication: All tests passed"
          echo "âœ… WebSocket Communication: All tests passed"
          echo "âœ… Concurrent Communication: All tests passed"
          echo "âœ… Performance Testing: All tests passed"
          echo "âœ… Linkerd Integration: All tests passed"
          echo "âœ… Error Handling: All tests passed"
          echo "âœ… Final Validation: All tests passed"
          echo ""
          echo "ğŸš€ gRPC and WebSocket communication infrastructure is fully operational!"
          
      restartPolicy: Never
  backoffLimit: 3
