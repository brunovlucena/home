apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-golden-signals-test
  namespace: k6-operator
  labels:
    app.kubernetes.io/name: k6-golden-signals-test
    app.kubernetes.io/component: load-test
    app.kubernetes.io/part-of: bruno-infrastructure
data:
  golden-signals-test.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter, Trend } from 'k6/metrics';

    // 🎯 Golden Signals Metrics
    const errorRate = new Rate('error_rate');
    const requestCounter = new Counter('requests_total');
    const latencyP95 = new Trend('latency_p95');
    const throughput = new Counter('throughput_total');

    // 📊 Test Configuration
    export const options = {
      scenarios: {
        golden_signals_test: {
          executor: 'ramping-vus',
          startVUs: 1,
          stages: [
            { duration: '30s', target: 5 },   // Ramp up to 5 VUs
            { duration: '2m', target: 5 },    // Stay at 5 VUs for sustained load
            { duration: '30s', target: 0 },   // Ramp down to 0 VUs
          ],
        },
      },
      thresholds: {
        // 🚨 Golden Signals Thresholds
        http_req_duration: ['p(95)<500'],     // 95% of requests should be below 500ms
        http_req_failed: ['rate<0.01'],       // Error rate should be below 1%
        error_rate: ['rate<0.01'],            // Custom error rate should be below 1%
        latency_p95: ['p(95)<500'],           // P95 latency should be below 500ms
      },
    };

        // 🌐 Service URLs
        const apiUrl = __ENV.BRUNO_SITE_API_URL || 'http://bruno-site-api.bruno:8080';
        const frontendUrl = __ENV.BRUNO_SITE_FRONTEND_URL || 'http://bruno-site-frontend.bruno:80';

    // 📝 Test Data
    const testMessages = [
      "Hello, can you tell me about your projects?",
      "What technologies do you work with?",
      "How can I contact you?",
      "Tell me about your experience",
      "What are your skills?"
    ];

    export default function () {
      // 🏥 Health Check Tests
      testHealthEndpoints();
      
      // 📊 API Endpoint Tests
      testApiEndpoints();
      
      // 🤖 Chat Endpoint Tests
      testChatEndpoint();
      
      // 🌐 Frontend Tests
      testFrontendEndpoints();
      
      // 📈 Metrics Collection
      requestCounter.add(1);
      throughput.add(1);
      
      sleep(1); // 1 second between iterations
    }

    // 🏥 Health Check Tests
    function testHealthEndpoints() {
      const healthEndpoints = [
        `${apiUrl}/health`,
        `${apiUrl}/metrics`,
        `${apiUrl}/api/v1/chat/health`
      ];

      healthEndpoints.forEach(url => {
        const response = http.get(url);
        const success = check(response, {
          'health check status is 200': (r) => r.status === 200,
          'health check response time < 200ms': (r) => r.timings.duration < 200,
        });
        
        errorRate.add(!success);
        latencyP95.add(response.timings.duration);
      });
    }

    // 📊 API Endpoint Tests
    function testApiEndpoints() {
      const apiEndpoints = [
        { url: `${apiUrl}/api/v1/projects`, method: 'GET' },
        { url: `${apiUrl}/api/v1/skills`, method: 'GET' },
        { url: `${apiUrl}/api/v1/experiences`, method: 'GET' },
        { url: `${apiUrl}/api/v1/about`, method: 'GET' },
        { url: `${apiUrl}/api/v1/contact`, method: 'GET' },
        { url: `${apiUrl}/api/v1/content`, method: 'GET' },
      ];

      apiEndpoints.forEach(endpoint => {
        const response = http.request(endpoint.method, endpoint.url);
        const success = check(response, {
          'API endpoint status is 200': (r) => r.status === 200,
          'API response time < 500ms': (r) => r.timings.duration < 500,
          'API response has content': (r) => r.body && r.body.length > 0,
        });
        
        errorRate.add(!success);
        latencyP95.add(response.timings.duration);
      });
    }

    // 🤖 Chat Endpoint Tests
    function testChatEndpoint() {
      const randomMessage = testMessages[Math.floor(Math.random() * testMessages.length)];
      const payload = JSON.stringify({
        message: randomMessage,
        context: "test"
      });

      const params = {
        headers: {
          'Content-Type': 'application/json',
        },
      };

      const response = http.post(`${apiUrl}/api/v1/chat`, payload, params);
      const success = check(response, {
        'chat endpoint status is 200': (r) => r.status === 200,
        'chat response time < 2000ms': (r) => r.timings.duration < 2000,
        'chat response has content': (r) => r.body && r.body.length > 0,
        'chat response is valid JSON': (r) => {
          try {
            JSON.parse(r.body);
            return true;
          } catch (e) {
            return false;
          }
        },
      });
      
      errorRate.add(!success);
      latencyP95.add(response.timings.duration);
    }

    // 🌐 Frontend Tests
    function testFrontendEndpoints() {
      const frontendEndpoints = [
        `${frontendUrl}/`,
        `${frontendUrl}/index.html`,
        `${frontendUrl}/static/css/main.css`,
        `${frontendUrl}/static/js/main.js`
      ];

      frontendEndpoints.forEach(url => {
        const response = http.get(url);
        const success = check(response, {
          'frontend status is 200': (r) => r.status === 200,
          'frontend response time < 300ms': (r) => r.timings.duration < 300,
          'frontend response has content': (r) => r.body && r.body.length > 0,
        });
        
        errorRate.add(!success);
        latencyP95.add(response.timings.duration);
      });
    }

    // 📊 Summary Statistics
    export function handleSummary(data) {
      const safeGet = (obj, path, defaultValue = 0) => {
        try {
          return path.split('.').reduce((o, p) => o && o[p], obj) || defaultValue;
        } catch (e) {
          return defaultValue;
        }
      };

      const totalRequests = safeGet(data, 'metrics.requests_total.values.count', 0);
      const throughput = safeGet(data, 'metrics.throughput_total.values.count', 0);
      const errorRate = safeGet(data, 'metrics.error_rate.values.rate', 0);
      const latencyP95 = safeGet(data, 'metrics.latency_p95.values.p95', 0);
      const httpFailed = safeGet(data, 'metrics.http_req_failed.values.rate', 0);

      return {
        'stdout': `
    🎯 Golden Signals Test Results:
    ================================
    📊 Total Requests: ${totalRequests}
    ⚡ Throughput: ${throughput} req/s
    🚨 Error Rate: ${(errorRate * 100).toFixed(2)}%
    ⏱️  P95 Latency: ${latencyP95.toFixed(2)}ms
    ✅ HTTP Success Rate: ${((1 - httpFailed) * 100).toFixed(2)}%
    ================================
        `,
      };
    }
