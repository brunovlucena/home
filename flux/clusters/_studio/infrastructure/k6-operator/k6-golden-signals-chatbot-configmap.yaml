apiVersion: v1
kind: ConfigMap
metadata:
  name: k6-golden-signals-chatbot
  namespace: k6-operator
  labels:
    app.kubernetes.io/name: k6-golden-signals-chatbot
    app.kubernetes.io/component: load-test
    app.kubernetes.io/part-of: bruno-infrastructure
data:
  golden-signals-chatbot.js: |
    import http from 'k6/http';
    import { check, sleep } from 'k6';
    import { Rate, Counter, Trend } from 'k6/metrics';

    // ğŸ¯ Golden Signals Metrics
    const errorRate = new Rate('error_rate');
    const requestCounter = new Counter('requests_total');
    const latencyP95 = new Trend('latency_p95');
    const throughput = new Counter('throughput_total');

    // ğŸ“Š Test Configuration
    export const options = {
      scenarios: {
        golden_signals_chatbot: {
          executor: 'ramping-vus',
          startVUs: 1,
          stages: [
            { duration: '30s', target: 3 },   // Ramp up to 3 VUs (lower for chatbot)
            { duration: '2m', target: 3 },    // Stay at 3 VUs for sustained load
            { duration: '30s', target: 0 },   // Ramp down to 0 VUs
          ],
        },
      },
      thresholds: {
        // ğŸš¨ Golden Signals Thresholds for Chatbot
        http_req_duration: ['p(95)<3000'],    // 95% of requests should be below 3s (chatbot is slower)
        http_req_failed: ['rate<0.05'],       // Error rate should be below 5%
        error_rate: ['rate<0.05'],            // Custom error rate should be below 5%
        latency_p95: ['p(95)<3000'],          // P95 latency should be below 3s
      },
    };

    // ğŸŒ Service URL
    const chatbotUrl = __ENV.CHATBOT_URL || 'http://jamie-sre-chatbot.chatbots:8080';

    // ğŸ“ SRE Test Messages
    const sreTestMessages = [
      "What are Bruno's development workflow preferences?",
      "How does Bruno deploy applications?",
      "What are Bruno's testing preferences?",
      "Tell me about Bruno's infrastructure setup",
      "What monitoring tools does Bruno use?",
      "How does Bruno handle CI/CD?",
      "What are Bruno's security practices?",
      "Tell me about Bruno's Kubernetes setup"
    ];

    export default function () {
      // ğŸ¥ Health Check Tests
      testHealthEndpoints();
      
      // ğŸ¤– Chat Endpoint Tests
      testChatEndpoints();
      
      // ğŸ“Š Metrics Endpoint Tests
      testMetricsEndpoints();
      
      // ğŸ“ˆ Metrics Collection
      requestCounter.add(1);
      throughput.add(1);
      
      sleep(2); // 2 seconds between iterations (chatbot needs more time)
    }

    // ğŸ¥ Health Check Tests
    function testHealthEndpoints() {
      const healthEndpoints = [
        `${chatbotUrl}/health`,
        `${chatbotUrl}/metrics`
      ];

      healthEndpoints.forEach(url => {
        const response = http.get(url);
        const success = check(response, {
          'health check status is 200': (r) => r.status === 200,
          'health check response time < 500ms': (r) => r.timings.duration < 500,
        });
        
        errorRate.add(!success);
        latencyP95.add(response.timings.duration);
      });
    }

    // ğŸ¤– Chat Endpoint Tests
    function testChatEndpoints() {
      const randomMessage = sreTestMessages[Math.floor(Math.random() * sreTestMessages.length)];
      const payload = JSON.stringify({
        message: randomMessage,
        context: "sre-test"
      });

      const params = {
        headers: {
          'Content-Type': 'application/json',
        },
      };

      const response = http.post(`${chatbotUrl}/chat`, payload, params);
      const success = check(response, {
        'chat endpoint status is 200': (r) => r.status === 200,
        'chat response time < 5000ms': (r) => r.timings.duration < 5000,
        'chat response has content': (r) => r.body && r.body.length > 0,
        'chat response is valid JSON': (r) => {
          try {
            JSON.parse(r.body);
            return true;
          } catch (e) {
            return false;
          }
        },
        'chat response contains useful content': (r) => {
          try {
            const data = JSON.parse(r.body);
            return data.response && data.response.length > 10;
          } catch (e) {
            return false;
          }
        },
      });
      
      errorRate.add(!success);
      latencyP95.add(response.timings.duration);
    }

    // ğŸ“Š Metrics Endpoint Tests
    function testMetricsEndpoints() {
      const metricsEndpoints = [
        `${chatbotUrl}/metrics`,
        `${chatbotUrl}/health`
      ];

      metricsEndpoints.forEach(url => {
        const response = http.get(url);
        const success = check(response, {
          'metrics endpoint status is 200': (r) => r.status === 200,
          'metrics response time < 1000ms': (r) => r.timings.duration < 1000,
          'metrics response has content': (r) => r.body && r.body.length > 0,
        });
        
        errorRate.add(!success);
        latencyP95.add(response.timings.duration);
      });
    }

    // ğŸ“Š Summary Statistics
    export function handleSummary(data) {
      return {
        'stdout': `
    ğŸ¤– Chatbot Golden Signals Test Results:
    ========================================
    ğŸ“Š Total Requests: ${data.metrics.requests_total.values.count}
    âš¡ Throughput: ${data.metrics.throughput_total.values.count} req/s
    ğŸš¨ Error Rate: ${(data.metrics.error_rate.values.rate * 100).toFixed(2)}%
    â±ï¸  P95 Latency: ${data.metrics.latency_p95.values.p95.toFixed(2)}ms
    âœ… HTTP Success Rate: ${((1 - data.metrics.http_req_failed.values.rate) * 100).toFixed(2)}%
    ========================================
        `,
      };
    }
